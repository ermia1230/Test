import { vi, describe, it, expect, afterEach} from "vitest";
vi.mock("/src/utilities");

// re-run these tests if the details presenter changes, in any framework
import.meta.glob("/src/reactjs/detailsPresenter.*sx")
import.meta.glob("/src/vuejs/detailsPresenter.*sx")

import {SuspenseView} from "/src/views/suspenseView";  // aliased to the dummy/ mock
import {DetailsView} from "/src/views/detailsView";  // aliased to the dummy/ mock

import {getModule} from "./getModule";
import {checkArrayCB} from "./checkCB";

vi.mock("mobx-react-lite");
import {observer} from "mobx-react-lite";
observer.mockImplementation(function(x){ x.observer=true; return x; }) ;

const testDish=    {
    id: 200,
    title: "Chocolate Ice cream",
    dishTypes: ["brunch", "dessert"],
    pricePerServing: 16.42,
    instructions: "Here is how you make it... Lore ipsum... bla",
    sourceUrl:"http://blabla.com/",
    image:"http://blabla.com/image.gif",
    extendedIngredients: [/*ingredients are tested separately*/],
	analyzedInstructions: [/*instructions are tested separately*/]
};

import {reactRender, vueRender} from "./render";

describe.for([
    {   name:"React/native",   render: reactRender , path:"reactjs"},
    {   name:"Vue",     render: vueRender  , path:"vuejs"},
])("TW2.3.2 $name Details presenter passes props to suspense and detail views", async function(framework){
    const {Details} = await getModule("/src/"+ framework.path+ "/detailsPresenter");

    it.runIf(Details).for([
	{ dishes:[], currentDishPromiseState:{}, param:{}},
	{ dishes:[], currentDishId:42, currentDishPromiseState:{promise:"dummyPromise"}, param:{promise:"dummyPromise"}},
	{ dishes: [], currentDishId:42, currentDishPromiseState:{promise:"dummyPromise", error:"dummyError"}, param:{promise:"dummyPromise", error:"dummyError"}},
    ])("sends promise and error to the SuspenseView", function(p){
	const {param, ...model}= p;
	framework.render(Details, {model});
	expect(SuspenseView).toHaveBeenCalledTimes(1);
	expect(SuspenseView.mock.lastCall[0]).toEqual(expect.objectContaining(param));
    });
    
    it.runIf(Details).for([
	{ numberOfGuests: 4, dishes: [], currentDishId:testDish.id, currentDishPromiseState:{data:testDish},
	  param:{guests:4, isDishInMenu:false, dishData: expect.objectContaining({id:testDish.id})}
	},
	{ numberOfGuests: 4, dishes: [{id:42}], currentDishId:testDish.id, currentDishPromiseState:{data:testDish},
	  param:{guests:4, isDishInMenu:false, dishData: expect.objectContaining({id:testDish.id})}
	},
	{ numberOfGuests: 5, dishes: [{id:40}, testDish, {id:42}],  currentDishId:testDish.id, currentDishPromiseState:{data:testDish}, 
	  param:{guests:5, isDishInMenu:true, dishData: expect.objectContaining({id:testDish.id})}
	},
    ])("renders DetailsView with correct props when dish data exists", function(p){
	const{param, ...model}= p;

	framework.render(Details, {model});
	expect(DetailsView).toHaveBeenCalledTimes(1);
	let detailsViewProps= DetailsView.mock.lastCall[0];
	expect(detailsViewProps.dishData).toEqual(param.dishData);
	expect(detailsViewProps.guests).toBe(param.guests);
	expect(detailsViewProps.isDishInMenu, "isDishInMenu should be a boolean (true/false)").toBeTypeOf('boolean');
	expect(detailsViewProps.isDishInMenu).toBe(param.isDishInMenu);

	const findMock= vi.spyOn(p.dishes, "find").mockImplementation(function(){ return "boolean value"; });

	// rerender
	framework.render(Details, {model});
	detailsViewProps= DetailsView.mock.lastCall[0];

	expect(findMock).toHaveBeenCalledTimes(1);
	const findCallback= findMock.mock.lastCall[0];
	expect(detailsViewProps.isDishInMenu).toBe(true);

	checkArrayCB(findCallback, "filter", "checking that dish is in menu");
	findMock.mockRestore();
    });
});
