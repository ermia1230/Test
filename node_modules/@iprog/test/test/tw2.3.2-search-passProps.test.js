import { vi, describe, it, expect, afterEach} from "vitest";
vi.mock("/src/utilities");

// re-run these tests if the search presenter changes, in any framework
import.meta.glob("/src/reactjs/detailsPresenter.*sx")
import.meta.glob("/src/vuejs/detailsPresenter.*sx")

import {SuspenseView} from "/src/views/suspenseView";  // aliased to the dummy/ mock
import {SearchFormView} from "/src/views/searchFormView";  // aliased to the dummy/ mock
import {SearchResultsView} from "/src/views/searchResultsView";  // aliased to the dummy/ mock

import {getModule} from "./getModule";

vi.mock("mobx-react-lite");
import {observer} from "mobx-react-lite";
observer.mockImplementation(function(x){ x.observer=true; return x; }) ;

import {reactRender, vueRender} from "./render";

describe.for([
    {   name:"React",   render: reactRender , path:"reactjs"},
    {   name:"Vue",     render: vueRender , path:"vuejs" },
])("TW2.3.2 $name Search presenter pass props to suspense and  search views", async function(framework){
    const {Search} = await getModule("/src/"+ framework.path+ "/searchPresenter");
    
    const dishTypeOptions=["starter", "main course", "dessert"];

    it.runIf(Search).for([
        {searchParams:{query:"dummy text", type:"dummy type"},
         form:{text:"dummy text", type:"dummy type", dishTypeOptions}},
        {searchParams:{query:"dummy text3", type:"dummy type3"},
         form:{text:"dummy text3", type:"dummy type3", dishTypeOptions} },
    ])
    ("Passes text, type and dishTypeOptions props to SearchFormView", function(p){
        const {form, dishTypeOptions, searchParams} =p;
        framework.render(Search, {model:{searchResultsPromiseState:{}, searchParams}});
        expect(SearchFormView).toHaveBeenCalledTimes(1);
        expect(SearchFormView.mock.lastCall[0]).toEqual(expect.objectContaining(form));
    });

    it.runIf(Search).for([
        {searchResultsPromiseState:{}, param:{} },
        {searchResultsPromiseState:{promise:"dummyPromise"},
         param:{promise:"dummyPromise"} },
        {searchResultsPromiseState:{promise:"dummyPromise", error:"dummyError"},
         param:{promise:"dummyPromise", error:"dummyError"}
        }])("sends promise and error to the SuspenseView", function(p){
            const {param, searchResultsPromiseState}= p;
            
            framework.render(Search, {model:{searchParams:{}, searchResultsPromiseState}});
            expect(SuspenseView).toHaveBeenCalledTimes(1);
            expect(SuspenseView.mock.lastCall[0]).toEqual(expect.objectContaining(param));
        });

     it.runIf(Search).for([
        {
            searchParams:{query:"dummy text", type:"dummy type"},
            searchResultsPromiseState:{promise:"dummyPromise", data:[{id:21}, {id:41}]},
            param:{searchResults:expect.arrayContaining([{id:21}, {id:41}])},
            form:{text:"dummy text", type:"dummy type", dishTypeOptions: ["starter", "main course", "dessert"]}
        },
        {
            searchParams:{query:"dummy text1", type:"dummy type1"},
            searchResultsPromiseState:{promise:"dummyPromise", data:[{id:20}, {id:42}]},
            param:{searchResults:expect.arrayContaining([{id:20}, {id:42}])},
            form:{text:"dummy text1", type:"dummy type1", dishTypeOptions: ["starter", "main course", "dessert"]}
        },])
    ("renders SearchResultsView with correct props when dish data exists", function(p){
        const{searchParams, searchResultsPromiseState, param, form}= p;
        framework.render(Search, {model: {searchParams, searchResultsPromiseState}});
        expect(SearchFormView).toHaveBeenCalledTimes(1);
        expect(SearchResultsView).toHaveBeenCalledTimes(1);
        expect(SearchFormView.mock.lastCall[0]).toEqual(expect.objectContaining(form));
        expect(SearchResultsView.mock.lastCall[0]).toEqual(expect.objectContaining(param));
    });
});
