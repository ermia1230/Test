import { vi, describe, it, expect } from "vitest";

import { getModule } from "./getModule";
const { getDishDetails, getMenuDetails } =await getModule("/src/dishSource");

import.meta.glob("/src/dishSource.*s");
import.meta.glob("/src/apiConfig.*s");

import {checkFetch} from "./checkFetch";
import {recordPromiseCB, stopPromiseRecording, checkPromiseCB} from "./checkCB";

const dishesConst=[
    {    id: 1,    title: "French toast",    dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,  },
    {    id: 2,    title: "Sourdough Starter",    pricePerServing: 11.22,    dishTypes: ["starter", "appetizer"],  },
];

function mockResponse(data){
    return Promise.resolve({
        ok: data?true:false,
        statusText:data?"OK":"Not found",
        status: data?200:404,
        json: () => Promise.resolve(data || {msg: "invalid IDs"}),
    });
}

describe.runIf(getMenuDetails)("TW2.1.3 API call: getMenuDetails", function tw2_1_3() {
  it("should fetch menu details with correct parameters", async function tw2_1_3_1() {
      const mockDishes = [dishesConst[0], dishesConst[1]];
      const dishIds = mockDishes.map((dish) => dish.id);
      
      window.fetch = vi
          .fn()
          .mockImplementationOnce(function (url, init) {
              // Verify URL and headers       
              checkFetch(url, init?.headers, -1115178555, [-1840291832]);
              return mockResponse(mockDishes);
          });
      
      let prms;
      recordPromiseCB();                
      try{
          prms= getMenuDetails(dishIds);
      }finally{ stopPromiseRecording(); }
      
      expect(prms).toBeInstanceOf(Promise);
      const result = await prms;
      
      expect(result).toStrictEqual(mockDishes);
      expect(window.fetch).toHaveBeenCalledTimes(1);
      checkPromiseCB("getMenuDetails");
  });

  it("rejects if the underlying fetch fails", async function tw2_1_3_2() {
        window.fetch = vi.fn().mockImplementationOnce(function (url, init) {
            checkFetch(url, init?.headers, -1115178555, [-1350703509]);
            return mockResponse();
        });
        
        // passing an undefined will normally induce a proxy error
        await expect(getMenuDetails(["undefined"])).rejects.toThrow();
        expect(window.fetch).toHaveBeenCalledTimes(1);
    });
});

describe.runIf(getDishDetails)("TW2.1.4 API call: getDishDetails", function tw2_1_4() {
  it("should fetch single dish details correctly", async function tw2_1_4_1() {
      const mockDish = dishesConst[0];

      window.fetch = vi
          .fn()
          .mockImplementationOnce(function (url, init) {
              checkFetch(url, init?.headers, -1115178555, [100061260]);
              return mockResponse([mockDish]);
          });

      const result = await getDishDetails(mockDish.id);
      
      expect(result).toStrictEqual(mockDish);
      expect(window.fetch).toHaveBeenCalledTimes(1);
  });

  it("should handle another dish ID correctly", async function tw2_1_4_2() {
      const mockDish = dishesConst[1];

      window.fetch = vi.fn().mockImplementationOnce(function (url, init) {
          checkFetch(url, init?.headers, -1115178555, [100061261]);      
          return mockResponse([mockDish]);
      });
      
      let prms;
      recordPromiseCB();                
      try{
        prms= getDishDetails(mockDish.id);
      }finally{ stopPromiseRecording(); }
      const result = await prms;
      
      expect(result).toStrictEqual(mockDish);
      expect(window.fetch).toHaveBeenCalledTimes(1);
      checkPromiseCB("getDishDetails");  
  });
});
