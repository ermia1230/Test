import { vi, describe, it, expect} from "vitest";
import {render, within, cleanup} from "@testing-library/react-native";
import {createElement} from "react";
import {getModule} from "./getModule";

// sidebarView may not exist yet. In that case we skip the test
const {SidebarView, noSidebarView}= await getModule("/src/native-views/sidebarView");

import {checkCB} from "./checkCB";

vi.mock("/src/utilities");
import {sortDishes, menuPrice, dishType} from "/src/utilities";

function dummySort(x){  return x; };
sortDishes.mockImplementation(dummySort);
menuPrice.mockImplementation(function(){return Math.random();});
dishType.mockImplementation(function(){return "dummy dish type "+Math.random();});

import {getProps} from "./nativeJsxMock";

describe("TW1.3  React Native  Array Rendering and basic styling", function tw1_3() {
    it.skipIf(noSidebarView).for([
	{
	    number:3,
	    dishes:[
		{  id: 1,  title: "French toast",   dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,},
		{  id: 2,  title: "Sourdough Starter",  pricePerServing: 11.22,  dishTypes: ["starter", "appetizer"],  summary: "Here is how you make it... Lore ipsum...",}
	    ],
	    expected:{k:1,  dishIndex:0, nm:"French toast", tp:"dummyType", cost:"64.02", n:3}
	},
	{
            number:2,
            dishes:[
		{  id: 1,  title: "French toast",   dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,},
		{ id: 3,   title: "Baked Brie with Peaches",  dishTypes: ["snack", "starter"], pricePerServing: 10.81,}
            ],
            expected:{k:3, dishIndex:1, nm:"Baked Brie with Peaches", tp:"dummyStart", cost:"21.62", n:2}
	}
    ])("SidebarView flatlist content", function tw1_3_3(p){
	const {expected, ...props}=p;
	
        const output= render(createElement(SidebarView, props));
	
        expect(sortDishes).toHaveBeenCalledWith(p.dishes);
	const sortDishesResult=sortDishes.mock.results[0].value;

        const flatListProps = getProps(output.getByText("iprog.FlatList"));	
        expect(flatListProps.data).toEqual(sortDishesResult);
    
        // check the last card in sidebar (the total price) first
        expect(output.getByText("Total price:")).toBeTruthy();
        expect(menuPrice).toHaveBeenCalledWith(p.dishes);

        const menuPriceResult= menuPrice.mock.results[0].value;
        expect(output.getByText((expected.n*menuPriceResult).toFixed(2))).toBeTruthy();

	// clean up to prepare another render
        cleanup();
        // render one dish (indicated by expected.dishIndex) by invoking the renderItem() callback                           
        const outputItem = render(flatListProps.renderItem({item: p.dishes[expected.dishIndex]}));

	// Outer pressable with role = link
	const links = outputItem.getAllByRole("link");
	expect(links).toHaveLength(1);
	checkCB(getProps(links[0]).__onPress, "link onPress");

	const outputDish = within(links[0]);

	// Dish name
	expect(outputDish.queryByText(p.dishes[expected.dishIndex].title)).toBeTruthy();

	// Dish type
	expect(dishType).toHaveBeenCalledWith(p.dishes[expected.dishIndex]);
	const dishTypeSpyResult=dishType.mock.results[0].value;
	expect(outputDish.queryByText(dishTypeSpyResult)).toBeTruthy();

	// Dish price ( use .toFixed(2)! )
	expect(outputDish.getByText(expected.cost)).toBeTruthy();

	// Inner pressable with role button (inside the link pressable)
	const buttons = outputDish.getAllByRole("button");
	expect(buttons).toHaveLength(1);
	checkCB(getProps(buttons[0]).__onPress, "button onPress");

	// the keyExtractor prop handles the keys. It should be the stringified dish id
	expect(flatListProps.keyExtractor(p.dishes[expected.dishIndex])).toBe(expected.k.toString());

	// Styling tests
    // ...

	checkCB(flatListProps.renderItem, "renderItem");
	checkCB(flatListProps.keyExtractor, "keyExtractor");
    });

});
    
