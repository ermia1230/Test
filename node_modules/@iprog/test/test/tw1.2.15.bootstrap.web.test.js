import {describe, it, vi, expect} from "vitest";

function jsxRender(Comp, props){ return Comp(props);}   // dummy render of a jsx component

vi.mock("vue");
import {h,createApp,reactive} from "vue";
h.mockImplementation(jsxRender);  // vue jsx 
vi.mock("vue-router");
vi.mock("/src/vuejs/VueRoot");
import { VueRoot} from "/src/vuejs/VueRoot";  

vi.mock("react-dom/client");
import {createRoot} from "react-dom/client";
vi.mock("react");
import{createElement} from "react";
createElement.mockImplementation(jsxRender);  // react jsx
vi.mock("/src/reactjs/ReactRoot", function(){
    return { ReactRoot:vi.fn() };
});
import { ReactRoot} from "/src/reactjs/ReactRoot";  

// needed for loading the reactive model modules 
vi.mock("/src/firestoreModel");
vi.mock("/src/DinnerModel");
vi.mock("mobx");
import {observable} from "mobx";

function clone(x){ return {...x};}       // clone instead of reactive


describe("bootstrapping mounts the UI in the '#root' element", async function(){
    // these mocks can be at the top of the file but we put each mock near its test
    // Vue mocks:
    createApp.mockImplementation(function(){ return { mount:vi.fn(), use:vi.fn()};});

    const vueReactiveMdl= "dummy Vue reactive model";
    vi.doMock("/src/vueReactiveModel", function(){return {reactiveModel:vueReactiveMdl};});

    // needed after we unmock and load vueReactieModel:
    reactive.mockImplementation(clone);
    
    it("Vue bootstrapping mounts VueRoot passing the correct 'model' prop", async function (test) {
	// mocks are in place, we can load the bootstrapping:
	await import("/src/vuejs/index");
	
	expect(createApp).toHaveBeenCalledTimes(1);
	const app= createApp.mock.results[0].value; 
	
	expect(app.mount).toHaveBeenCalledTimes(1);
	const mountParam= app.mount.mock.lastCall[0]; 
	
	if ( mountParam != "#root") 
	    test.skip();
	
	let createAppParam = createApp.mock.lastCall[0];  // first param of call
	if (typeof createAppParam === "function")
	    // vue createApp param can be a component or a function returning the component
	    createAppParam = createAppParam();
	
	expect(VueRoot).toHaveBeenCalledWith({model:vueReactiveMdl});
	expect(createAppParam).toBe(VueRoot.mock.results[0].value);
	
	// we now know that the export of vueReactiveObject is used for VueRoot,
	// we need to check that it is a reactive object
	vi.doUnmock("/src/vueReactiveModel");
	
	const ret= await import("/src/vueReactiveModel");
	expect(ret.reactiveModel).toBe(reactive.mock.results[0].value);
  });





    // React and mobx mocks:
    createRoot.mockImplementation(function(){return { render:vi.fn() };});
    
    const mobxReactiveMdl= "dummy Mobx reactive model";
    vi.doMock("/src/mobxReactiveModel", function(){ return {reactiveModel:mobxReactiveMdl};});

    // needed after we unmock and load mobxReactieModel:
    observable.mockImplementation(clone);


    it("React bootstrapping mounts ReactRoot passing the correct 'model' prop", async function (test) {
	const getElementById= vi.spyOn(document, "getElementById");
	
	// mocks are in place, we can load the bootstrapping:	
	await import("/src/reactjs/index");
	expect(getElementById).toHaveBeenCalledTimes(1);
      
	expect(createRoot).toHaveBeenCalledWith(getElementById.mock.results[0].value);

	const mountRoot= createRoot.mock.results[0].value;
	expect(mountRoot.render).toHaveBeenCalledTimes(1);
	
      if ( getElementById.mock.lastCall[0] // first parameter of the getElementById call
	   != "root") 
	  test.skip();
      
	let renderParam = mountRoot.render.mock.lastCall[0];  // first param of the render call
	
	expect(ReactRoot).toHaveBeenCalledWith({ model: mobxReactiveMdl});
	
	expect(renderParam).toBe(ReactRoot.mock.results[0].value);
	
	// we now know that the export of mobxReactiveObject is used for ReactRoot,
	// we need to check that it is a reactive object
	vi.doUnmock("/src/mobxReactiveModel");
	
	const ret= await import("/src/mobxReactiveModel");
	expect(ret.reactiveModel).toBe(observable.mock.results[0].value);
    });
});


