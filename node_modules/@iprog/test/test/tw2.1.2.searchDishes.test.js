import { vi, describe, it, expect, beforeEach } from "vitest";
import { checkFetch } from "./checkFetch";
import { recordPromiseCB, stopPromiseRecording, checkPromiseCB } from "./checkCB";
import { getModule } from "./getModule";

const {searchDishes}= await getModule("/src/dishSource");

import.meta.glob("/src/dishSource.*s");
import.meta.glob("/src/apiConfig.*s");

const dishesConst = [
    {    id: 1,    title: "French toast",    dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,  },
    {    id: 2,    title: "Sourdough Starter",    pricePerServing: 11.22,    dishTypes: ["starter", "appetizer"],  },
    {    id: 3,    title: "Baked Brie with Peaches",    dishTypes: ["snack", "starter"],    pricePerServing: 10.81,  },
];

// Mock the global fetch
const mockFetch =  vi.fn(function(){
    return Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve(mockSearchResponse),
    });
});

window.fetch = mockFetch;

const mockSearchResponse = {
  results: dishesConst.slice(0, 3).map((dish) => ({
    id: dish.id,
    title: dish.title,
    image: dish.image,
    sourceUrl: dish.sourceUrl,
  })),
  totalResults: 3,
  offset: 0,
  number: 3,
};

describe.runIf(searchDishes)("TW2.1.2 API call: search", function tw2_1_2() {

    it("uses the correct proxy, API endpoint and HTTP headers", function tw2_1_2_1() {
        let prms;
        recordPromiseCB();        
        try{
            prms=searchDishes({});
        }finally{ stopPromiseRecording(); }
        // expecting searchDishes to return a promise    
        expect(prms).toBeInstanceOf(Promise);
        expect(mockFetch).toHaveBeenCalled();
        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, []);
      checkPromiseCB("search dishes");
    });

    it("keeps only one of the API result properties: an array of dishes", async function tw2_1_2_2() {
        const result = await searchDishes({});
        
        expect(result).toEqual(mockSearchResponse.results);
    });
    
    it("sends the correct query string: testing with type 'main course'", async function tw2_1_2_3() {
        await searchDishes({ type: "main course" });
        
        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, [1758563338]);
    });

    it("sends the correct query string: testing with pizza as main course", async function tw2_1_2_4() {
        await searchDishes({ query: "pizza", type: "main course" });
        
        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, [-1894851277, 1758563338]);
    });

    it("searchDishes strawberry pie as dessert", async function tw2_1_2_5() {
        await searchDishes({ query: "strawberry pie", type: "dessert" });

        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, [-1015451899, 1496539523]);
    });

    it("searchDishes strawberry pie", async function tw2_1_2_6() {
        await searchDishes({ query: "strawberry pie" });
        
        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, [-1015451899]);
    });

    it("searchDishes with no search criteria (empty object)", async function tw2_1_2_7() {
        await searchDishes({});
        
        const [url, params] = mockFetch.mock.calls[0];
        checkFetch(url, params.headers, -281827937, []);
    });


  it("handles API errors appropriately", async function tw2_1_2_8() {
      mockFetch.mockImplementationOnce(function(){
          return Promise.resolve({
              ok: false,
              status: 500,
              statusText: "Internal Server Error",
          });
      });
      
      await expect(searchDishes({})).rejects.toThrow();
  });
});
