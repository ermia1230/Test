import { vi, describe, it, expect, afterEach} from "vitest";
import {render, screen, cleanup} from "@testing-library/react";
import {createElement, Fragment} from "react";
import {getModule} from "./getModule";

// re-run the test if anything happens with the sidebarView file
import.meta.glob("/src/views/sidebarView.*sx");

// sidebarView may not exist yet. In that case we skip the test
const {SidebarView, noSidebarView}= await getModule("/src/web-views/sidebarView");

import {checkArrayCB} from "./checkCB";

vi.mock("/src/utilities");
import {sortDishes, menuPrice, dishType} from "/src/utilities";
sortDishes.mockImplementation(dummySort);
menuPrice?.mockImplementation(function(){return Math.random();});
dishType?.mockImplementation(function(){return "dummy dish type "+Math.random();});

function dummyRow(){ return createElement("tr",{}, createElement("td", {},"dummy rendered array"));}
function dummySort(){  return {map: vi.fn(dummyRow)}; }
function dummyTable(x){ return createElement("table",{}, createElement("tbody", {},x));}

import {getProps} from "./webJsxMock";

let sidebarText;
try{
    sidebarText= SidebarView && typeof SidebarView({number:2, dishes:[]})=="string" ;
}catch(e){}

describe("TW1.3  Vue/React  Array Rendering and basic CSS", function tw1_3() {
    afterEach(cleanup);
    it.skipIf(noSidebarView || sidebarText).for([
	{
	    number:3,
	    dishes:[
		{  id: 1,  title: "French toast",   dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,},
		{  id: 2,  title: "Sourdough Starter",  pricePerServing: 11.22,  dishTypes: ["starter", "appetizer"],  summary: "Here is how you make it... Lore ipsum...",}
	    ],
	    expected:{k:1,  dishIndex:0, nm:"French toast", tp:"dummyType", cost:"64.02", n:3}
	},
	{
            number:2,
            dishes:[
                {  id: 1,  title: "French toast",   dishTypes: ["snack", "appetizer"],    pricePerServing: 21.34,},
		{ id: 3,   title: "Baked Brie with Peaches",  dishTypes: ["snack", "starter"], pricePerServing: 10.81,}
            ],
            expected:{k:3, dishIndex:1, nm:"Baked Brie with Peaches", tp:"dummyStart", cost:"21.62", n:2}
        }
    ])("SidebarView table content", function tw1_3_3(p){
	const {expected, ...props}=p;

        const output= render(createElement(SidebarView, props));

        expect(sortDishes).toHaveBeenCalledWith(p.dishes);
	const sortDishesResult=sortDishes.mock.results[0].value;
        expect(sortDishesResult.map).toHaveBeenCalled();              

        const tableRows = output.queryAllByRole('row');	
	// we replace array rendering with a dummy table row. It should be the first table row
        expect(tableRows[0].cells[0].textContent).toBe("dummy rendered array");
	const totalCell=tableRows[1]?.cells[3];
	const totalCellStyle= totalCell&& window.getComputedStyle(totalCell).textAlign;
	
        const mapParam=sortDishesResult.map.mock.calls[0][0];
	expect(sortDishesResult.map.mock.calls[0].length).toBe(1);  // map only has one parameter!

	// clean up to prepare another render
        cleanup();
        // render one dish (indicated by expected.dishIndex) by invoking the map() callback                             
        const rows= render(dummyTable(mapParam(p.dishes[expected.dishIndex]))).queryAllByRole("row");

        expect(rows.length).toBe(1);
        const tds= rows[0].cells;
	expect(tds.length).toBe(4);

	// first column
	expect(tds[0].textContent.trim().toLowerCase()).toBe("x");
	expect(tds[0].firstElementChild?.tagName).toBe("BUTTON");

	// second column (name)
	expect(tds[1].textContent.trim()).toBe(expected.nm);

	// 3rd column (type)
	expect(dishType).toHaveBeenCalledWith(p.dishes[expected.dishIndex]);
	const dishTypeSpyResult=dishType.mock.results[0].value;
	expect(tds[2].textContent.trim()).toBe(dishTypeSpyResult);

	// 4th column (amount, use .toFixed(2)! )
	expect(tds[3].textContent.trim()).toBe(expected.cost);

	// link on second column
	expect(tds[1].firstElementChild?.tagName).toBe("A");
	//dish name HTML link should point to the same page (#) to prevent full page reload
	expect(tds[1].firstElementChild?.getAttribute("href")[0]).toBe("#");

	// alignment of 4th column: must use a css class, not inline style
	expect(tds[3].className).toBeTruthy();
	// css align right
	expect(window.getComputedStyle(tds[3]).textAlign).toBe("right");

	// we've copied the key to the data-key prop so we can test it. It should be the dish id
	expect(getProps(rows[0])["data-key"]).toBe(expected.k);

	// last row must be the total
	// totalCell and its style defined above, stlye must be read before cleanup
	expect(tableRows.length).toBe(2);

	expect(tableRows[1].cells[1].textContent.trim()).toBe("Total:");
	expect(menuPrice).toHaveBeenCalledWith(p.dishes);
	const menuPriceResult= menuPrice.mock.results[0].value;

	expect(totalCell.textContent.trim()).toBe((expected.n*menuPriceResult).toFixed(2));
	// must use a css class, not inline style
	expect(totalCell.className).toBeTruthy();
	// css align right
	expect(totalCellStyle).toBe("right");

	checkArrayCB(mapParam, "map", "rendering dishes");
    });

});
    
