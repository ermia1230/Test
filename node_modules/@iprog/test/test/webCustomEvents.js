import { fireEvent, render, cleanup} from "@testing-library/react";

import {vi, expect} from "vitest";

import {customEventWrap} from "./customEventWrap";
import {createElement, Fragment} from "react";

vi.mock("/src/utilities");
import {sortDishes, menuPrice, dishType} from "/src/utilities";
sortDishes.mockImplementation(dummySort);
menuPrice?.mockImplementation(function(){return Math.random();});
dishType?.mockImplementation(function(){return "dummy dish type "+Math.random();});
function dummySort(x){  return x; }

import {getProps} from "./webJsxMock";

// all web views are rendered with React!
// ignore whitespace, empty lines, etc. This is useful for the tree approach to finding components
/*
function skipSpacesCB(x){ return typeof x!=="string" || x.trim() ;}

  window.React={
    createElement(comp, props, ...rest){
	return createElement(comp, props, ...rest.filter(skipSpacesCB));
    },
    Fragment
}*/

import {getModule} from "./getModule";

const {SidebarView, noSidebarView}= await getModule("/src/web-views/sidebarView");
const {DetailsView, noDetailsView}= await getModule("/src/web-views/detailsView");
const {SearchFormView, noSearchFormView}= await getModule("/src/web-views/searchFormView");
const {SearchResultsView, noSearchResultsView}= await getModule("/src/web-views/searchResultsView");

const cache={};
export const webCustomEvents={
    searchResults(){
	expect(SearchResultsView, "could not find or load web search results view "+ noSearchResultsView).toBeTruthy();
	const wrappedSearchResultsView= customEventWrap(SearchResultsView);
	const output= render(createElement(wrappedSearchResultsView, {searchResults:[{
	    id: 587203,
	    title: "Taco Pizza",
	    readyInMinutes: 20,
	    servings: 6,
	    sourceUrl: "https://laurenslatest.com/taco-salad-pizza-with-doritos/",
	    openLicense: 0,
	    image: "https://laurenslatest.com/wp-content/uploads/2020/12/Taco-Pizza-02-copy.jpg",
	    
	}]}));
	const span=output.container.children[0]  // DIV
	      .children[0];  //SPAN
	fireEvent.click(span);

	const customEvent= wrappedSearchResultsView.popCustomEvent();

	// one paramtere expected to be passed to the custom event handler (the chosen dish)
	expect(customEvent.params.length).toBe(1);
	return {["search result chosen"]:customEvent, complete:true};
    },
    searchForm(){
	window.React={createElement, Fragment};
	const searchFormCustomEvents={};
	expect(SearchFormView, "could not find or load web search form view "+ noSearchFormView).toBeTruthy();

	const wrappedSearchFormView= customEventWrap(SearchFormView);
	const output = render(createElement(
	    wrappedSearchFormView,
	    {
		text:"",
		type:"",
		dishTypeOptions:["a", "b"]
	    }));

	
	const textBox=output.getByRole("textbox");
	fireEvent.change(textBox, {target:{value:"bla2"}});
	searchFormCustomEvents["search text change"]= wrappedSearchFormView.popCustomEvent("on textbox change");

	const selectBox=output.getByRole('combobox');

	// we invoke the event handler directly rather than firing the event, due to this bug
	// https://github.com/testing-library/react-testing-library/issues/908
	getProps(selectBox).onChange({target:{value:"bla7"}});

	searchFormCustomEvents["search type change"]= wrappedSearchFormView.popCustomEvent("on combobox change");

	
	const searchBtn=output.getByRole("button", {name: /search/i});
	fireEvent.click(searchBtn);

	searchFormCustomEvents["search now"]= wrappedSearchFormView.popCustomEvent("on search button click");


	// custom events handlder for search text and type should receive one parameter (the text or type)
	expect(searchFormCustomEvents["search text change"].params.length).toBe(1);
	expect(searchFormCustomEvents["search type change"].params.length).toBe(1);
	
	// no parameters needed, we just need to know that the user wants to search
	expect(searchFormCustomEvents["search now"].params.length).toBe(0);
	searchFormCustomEvents.complete= true;
	return searchFormCustomEvents;
    },
    
    details(){
	window.React={createElement, Fragment};
	const detailsCustomEvents={};
	expect(DetailsView, "could not find or load web details view "+ noDetailsView).toBeTruthy();

	const wrappedDetailsView= customEventWrap(DetailsView);
	const {getByRole} = render(createElement(
	    wrappedDetailsView,
	    {
		guests:4,
		dishData:  {id: 2,  title: "Sourdough Starter",  pricePerServing: 11.22,  dishTypes: ["starter", "appetizer"],  summary: "Here is how you make it... Lore ipsum...", extendedIngredients:[]},
		isDishInMenu:false
	    }));
	const btn= getByRole("button", {name: /add to menu/i});
	expect(btn).toBeTruthy();
	fireEvent.click(btn);
	detailsCustomEvents["add to menu"]= wrappedDetailsView.popCustomEvent("on add to menu");

	// no parameters needed, the custom event means that the current dish is being added to the menu
	expect(detailsCustomEvents["add to menu"].params.length).toBe(0);
	detailsCustomEvents.complete= true;
	return detailsCustomEvents;
    },

    sidebar(){
	window.React={createElement, Fragment};
	const sidebarCustomEvents= {};
	expect(SidebarView, "could not find or load web sidebar view "+ noSidebarView).toBeTruthy();
	
	// finding components using React testing-library
	const wrappedSidebarView= customEventWrap(SidebarView);
	
	const {getAllByRole}= render(createElement(
	    wrappedSidebarView,
	    {number:2,
	     dishes:[  {id: 2,  title: "Sourdough Starter",  pricePerServing: 11.22,  dishTypes: ["starter", "appetizer"],  summary: "Here is how you make it... Lore ipsum...",}]
	    }));
	
	const buttons= getAllByRole("button");
	expect(buttons.length).toBe(3);
	
	fireEvent.click(buttons[0]);
	sidebarCustomEvents["decrease number"]= wrappedSidebarView.popCustomEvent();
	
	fireEvent.click(buttons[1]);
	sidebarCustomEvents["increase number"]= wrappedSidebarView.popCustomEvent();

	// increasing and decreasing the number should fire the same custom event, only with different parameter
	expect(sidebarCustomEvents["increase number"].name).toBe(sidebarCustomEvents["decrease number"].name);
	
	fireEvent.click(buttons[2]);
	sidebarCustomEvents["remove dish"]= wrappedSidebarView.popCustomEvent();
	
	const anchors= getAllByRole("link");    
	expect(anchors.length).toBe(1);    
	fireEvent.click(anchors[0]);
	sidebarCustomEvents["select dish"]=  wrappedSidebarView.popCustomEvent();

	// all custom events fired by sidebar get one parameter
	expect(sidebarCustomEvents["increase number"].params.length).toBe(1);
	expect(sidebarCustomEvents["decrease number"].params.length).toBe(1);
	expect(sidebarCustomEvents["select dish"].params.length).toBe(1);
	expect(sidebarCustomEvents["remove dish"].params.length).toBe(1);

	sidebarCustomEvents.complete= true;
	return sidebarCustomEvents;
	
	/*
	  finding components using React tree  
      
    const div=  wrappedSidebarView({number:2, dishes:[dishesConst[0]]})

    expect(div.props.children[0].type).toBe("button");
    div.props.children[0].props.onClick();
    sidebarCustomEvents["decrease number"]={...sidebarViewState};

    expect(div.props.children[2].type).toBe("button");
    div.props.children[2].props.onClick();
    sidebarCustomEvents["increase number"]={...sidebarViewState};

    const tr=     rendering.props.children[3] // table
          .props.children. // tbody, only child
          props.children[0][0];

    const col1= tr.props.children[0]
    expect(col1.type).toBe("td")
    expect(col1.props.children[0].type).toBe("button");
    col1.props.children[0].props.onClick();
    sidebarCustomEvents["dish remove"]={...sidebarViewState};

    const col2= tr.props.children[1];
    expect(col2.type).toBe("td")
    expect(col2.props.children[0].type).toBe("a");
    col2.props.children[0].props.onClick();
    sidebarCustomEvents["dish select"]={...sidebarViewState};
    */
    },
    getCustomEvents(view){
	if(cache[view])
	    return cache[view];
	try{
	    return cache[view]=this[view]();
	}catch(e){
	    console.log(e);
	    return cache[view]={ error:e, complete:false};
	}
    }
};



