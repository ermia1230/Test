# How to work with the tutorial6 Vitest tests

## source files
Copy the lab files to `src/`(ignored by .gitignore) in the following structure
* `src/reactjs`  React and React native presenters (they must be identical in the lab). They import from `/src/views`. This folder also includes the React web bootstrapping and ReactRoot.
* `src/vuejs`  Vue presenters. They import from `/src/views`. This folder also includes the Vue (web) bootstrapping and VueRoot.
* `src/views` web Views. They are tested with React
* `src/native-views` React Native views. At runtime they are aliased to `/src/views` so the import from the React presenter works
* `src/app`   React native router

## running (testing) the tests
`npm run test` will run all tests: Web (React, Vue) and React Native. Just in case we will need to filter out the Web or Native tests, all Web View tests have the suffix `*.web.test.js` and all Native View tests have the suffix `*.native.test.js`

## test basics
```
import{describe, it, expect} from "vitest"
describe("a group of tests", function(){
   it("an individual test", function(){
       expect(1+1, "should be two").toEqual(2);    
   })
})
```

## getModule: importing possibly missing files without errors
Using an ordinary import statement for e.g. `reactjs/sidebarPresenter` before the presenter is created by the student, will fail the test, which is not what we want since maybe e.g. the student wants to work on the Vue presenter instead. To avoid that, use the `getModule` utility

```
import {getModule} from "./getModule"

const {Sidebar, noSidebarPresenter}= await getModule("/src/reactjs/sidebarPresenter")
```

If the module does not exist or cannot be parsed by Vite, `Sidebar` will be falsy and `noSidebarPresenter` will be truthy and assigned to the error.

Note: importing with getModule will not re-run the test when the respective module changes! To force that to happen, you need to add this:

```
import.meta.glob("/src/reactjs/sidebarPresenter.*sx")
```

This expression will actually return an array of file names (`[]`, or `["sidebarPresenter.jsx"]`, or `["sidebarPresenter.tsx"]`) that exist on disk with that pattern, but we don't need the result. Usage of the import.meta.glob leads to vitest re-running the test file when a file of the indicated pattern appears or changes.

## skipping tests if certain conditions are not fulfiled
If a presenter is missing, or its view is missing, or (for TW1.5 and TW2.5) the view custom events cannot be detected, or the student did not start yet to work with persistence or navigation, etc, we can skip a test like so:

`it.skipIf(someCondition)("test description", function(){...})`

We can also decide to skip during the test itself:

`it("test description", function(context){  .. ;  if(condition) context.skip(); ..})`


## multiple test cases
We often want to test a presenter, view or function with multiple test cases, to make sure that the student does not doctor their code to work for just one case. 

`it.for(someArray)("test description", function(arrayElement){...})`

If the `arrayElement` is itself an array, `%s` will display it in the test name
`it.for(someArray)(someCondition)("%s test description", function([name, otherElements]){...})`

`for()` can be combined with `skipIf()`:

`it.skipIf(someCondition).for(someArray)(someCondition)("%s test description", function(arrayElement){...})`

`describe.for()` also works:

`describe.for(someArray)("%s description", function([name, etc]){..})`

## Testing Library (mostly used for Views)
We use the [Testing Library](https://testing-library.com/) for React, React Native and Vue to render components in the three frameworks. The Testing Library is very focused on "what the user sees" (text, different types of interactive elements). The user does not see the component tree for example, hence it is not (directly) revealed by Testing Library. Even the props of an interactive element are not something that the user sees and thus are not revealed in a uniform way.

First we need to create a rendering:
```
import {render} from "@testing-library/react"  // or @testing-library/react-native!!!

const {getByText, getAllByRole}= render(<SomeComponent prop1={v1} p2={v2} />)
```

To skip the JSX syntax for just rendering, in most tests we use a JSX `createElement` function (see details below)
```
import {createElement} from "react"
import {render} from "@testing-library/react" // or @testing-library/react-native!!!

const {getByText, getAllByRole}= render(createElement(SomeComponent, {prop1:ve, p2:v2}))

// once the rendering object is available, we can look for different interactive elements:
const buttons= getAllByRole("button")  // <button > in web,  <Button> or <View role="button" >  in native
const links= getAllByRole("link")   // <a > in web, <Pressable role="link" > in native
```

If you do `getAllByRole("blabla")`, Testing Library will show you the possible roles for the respective platform (Web or Native). As you can see above, **in most native elements, the role must be set explicitly**. See a [list of available native roles](https://reactnative.dev/docs/accessibility#role).

### Beyond testing-library: working with component trees and props
It is possible to work withoug Testing Library: just examine the component tree returned by e.g. `SomeComponent(props)`. The tree is dependent on the framework and differs between React and React Native (and Vue of course). In the tree you can find each element props. See [example for React Native](https://gits-15.sys.kth.se/iprog/iprog-test/blob/00d0146ec7066af03e52531799a904fbad5057e9/test/nativeCustomEvents.js#L45), [example for React](https://gits-15.sys.kth.se/iprog/iprog-test/blob/00d0146ec7066af03e52531799a904fbad5057e9/test/webCustomEvents.js#L51)

Also, once you get hold of an interactive element (or the rendering `root`) via Testing Library, you can access its subtree and its props, in a framework-dependent manner. For example in React Native a button props: `button._fiber.stateNode.props`. We have a `getProps(element)` utility for that.


### testing FlatLists, Images, SegmentedControls
FlatList does not work in the vitest environment, and we don't need it to actually work, we only need to know that the student passes the correct props. FlatLists are replaced with a `<Text>iprog.FlatList</Text>` (see below how if you are interested) and the props of the Text are the original flatlist props.

```
import {createElement} from "react"
import {render} from "@testing-library/react-native" 
import {getProps} from "./nativeJsxMock"
const {getByText, getAllByRole}= render(createElement(SomeComponent, {prop1:ve, p2:v2}))

const flatListProps=getProps(getByText("iprog.FlatList"))
```

One thing we will want is to test whether each array element is rendered correctly. For that, we can simply render an element, by calling `flatListProps.renderItem(..)`! Since getByText, getAllByRole are assigned, we can set new names

```
const {getByText:getByTextInRow, getAllByRole:getAllByRoleInRow}= render(flatListProps.renderItem({item: someDish}))
expect(getByTextInRow("French Toast")).toBeTruthy()

```
Similarly, you can test the item key, etc.

Expo `Image` does not work in the vitest environment either, but, like with `FlatList`, we want to make sure that its props are correct. We do the same with `SegmentedControl`

## mocking and spying
When testing a certain module, we don't want the modules it depends on to run, because the module may be correct but errors in the other modules may lead to failure. Therefore we *mock* the respective module. Mocking a module transforms all of its functions into functions that do nothing but can be spied on. 

The typical spy in the tests: we mock a whole module and spy on a few functions from it. We change the default spy behaviour (which does nothing) using `.mockImplementation`. 

```
vi.mock("vue")
import {reactive} from "vue"  // a spy which does nothing and returns undefined
reactive.mockImplementation(function(x){ return {...x};})  // a clone

...

expect(reactive).toHaveBeenCalledWith(model)
expect(reactive.mock.calls[0][0]).toBe(model)   // same as above! First parameter of first call
expect(reactive.mock.results[0].value).toEqual(model) // it will pass since the mock implementation returns a clone

```

Mocking without a static import:


```
const reactive= vi.spyOn(await import("vue"), "reactive").mockImplementation(..etc...)
const getElementById= vi.spyOn(document, "getElementById")
```

### all views are mocked!

All `/src/views`, `ReactRoot` and `VueRoot` are aliased to `test/dummy/` which contain mocks like `export const SummaryView=vi.fn()`. To find the actual student code, see "finding views" below.

```
import {SomeView} from "/src/views/someView"  // we are actually importing the mock from dummy/, not the student code
import {SomePresenter} from "/src/reactjs/somePresenter"  // the view import actually imports the mock
it("test description", function(){
   render(<SomePresenter model={someModel} />)

   expect(SomeView).toHaveBeenCalled()
   console.log(SomeView.mock.calls[0][0])       // first paramteter of the first spy call
   console.log(SomeView.mock.results[0].value)  // result of the first spy call, should be "dummy"
   // in other use cases we can check that the result is passed to other spies etc
})
```

### automatic mock cleaning implemented
If a spy is invoked several times, these calls will accumulate 
in the `theSpy.mock.calls` array so to get to the latest call we would need to use `theSpy.mock.calls.slice(-1)`  etc.

To simplify this, vitest is configured to clean mocks after every test (see `clearMocks:true`  in `vite.config.mjs`)

You can also call `SomeView.mockClear()` to e.g. manage multiple calls to `SomeView(props)` within a test, etc

### vi.mock with function

This will replace the whole utilities module with an empty `sortIngredients`. Importing anything else will lead to an error
```
vi.mock("/src/utilities", function(){
  return { sortIngredients: vi.fn()};     // a spy!
}

import {sortIngredients} from "/src/utilities"
```

We prefer to mock the whole module instead, and redefine a few spies using `spyOn(..).mockImplementation(..)`. See above

### vi.doMock Vs. vi.mock
vi.mock is hoisted up to the top of the file, just before all import statements (which are also hoisted)

Sometimes you want to control the moment when something is mocked, maybe you want to mock only when a function runs etc. To get the spy in this case, you need to use `await import` instead of `import` (which is hoisted and would thus be executed before the doMock).  In this case the presenter also needs to be loaded with `await import` or `await getModule`: a normal (hoisted) `import` would import the real view, not the mock!

```
vi.doMock("/src/utilities", function(){
  return { sortIngredients: vi.fn()};     // a spy!
}

const {sortIngredients} = await import ("/src/utilities")
```

`vi.fn()` is actually implemented with `vi.spyOn({ spy:function(){}}, "spy"})`. So if you want a spy function with another name than "spy", just write `vi.spyOn({myName:function(){}}, "myName")`


## finding Views
Test views in the `*.native.test.js` or `*.web.test.js` test files

Web views are found under the virtual path `/src/web-views` . Impoting or using `getModule` on `/src/web-views/someView` will actually load the file `src/views/someView`. The detailed reasons for that are found in the end of this document.

`reactjs/ReactRoot` and `vuejs/VueRoot` are found under the virtual path `root-views`

```
// twX.Y.someView.web.test.js
import {SummaryView} from "/src/web-views/SummaryView"
const {SomeView, noSomeView} = await getModule("/src/web-views/someView")
import {ReactRoot} from "/src/root-views/ReactRoot"
```

```
// twX.Y.someView.native.test.js
import {SummaryView} from "/src/native-views/summaryView"
const {SomeView, noSomeView} = await getModule("/src/native-views/someView")
```

## testing presenters
Presenter tests are done in a `describe.for()` for all three frameworks. The generic view mock `test/dummy/someView` is used for the test (not the real native view or web view)

```
import {reactRender, vueRender, nativeRender} from "./render";
import {SomeView} from "/src/views/someView";  // aliased to test/dummy/someView                                                                   

describe("some presenter test", function(){
    describe.for([
    {   name:"React",           render: reactRender},
    {   name:"Vue",             render: vueRender},
    {   name:"React Native",    render: nativeRender}
    ])
    ("$name Some Presenter", async function(framework){
        const {Some}= await import("/src/"
                                  + (framework.name.includes("React")?"reactjs":"vuejs")
                                  +"/somePresenter");
        it("test some presenter feature", function(){  
            framework.render(Some, theProps);
	    expect(SomeView).toHaveBeenCalled()  // mocked view is used here
	    // ..etc
        })
    })
})
```

The tests will usually `skipIf` the presenter does not exist, or its view is missing:
```
        const {Some, noSomePresenter}= await getModule("/src/"
                                  + (framework.name.includes("React")?"reactjs":"vuejs")
                                  +"/somePresenter");
         const {noSomeView}= await getModule("/src/"
                                             + (framework.name.includes("Native")?"native":"web")
                                             +"-views/someView");

         it.skipIf(noSomePresenter || noSomeView)("test a certain presenter feature, function(){
             // etc
```
## finding the name of custom events
Custom event name discovery is done in `webCustomEvents.js` and `nativeCustomEvents.js` respectively. These files render the view with React and React Native respectively. The view is wrapped by `customEventWrap` which detects all accesses to props that don't exist, which are probably custom events.

The wrapped View has a method called `customEventPop()` which checks (1) that an unknown prop (the custom event) was accessed (2) that the custom event with that name was fired and (3) that it was fired only once.

Note also that the custom events are identified by generic names such as `"increase number"`, `"remove dish"` etc. The actual name is found like `getCustomEvents("sidebar")["select dish"].name`. 

```
import {customEventWrap} from "./customEventWrap";
import {createElement} from "react";
import {getModule} from "./getModule"


const {SidebarView, noSidebarView}= await getModule("/src/web-views/sidebarView");

function sidebar(){
    const sidebarCustomEvents={}
    expect(SidebarView, "could not find or load web sidebar view "+ noSidebarView).toBeTruthy();

    // wrap the view:
    const wrappedSidebarView= customEventWrap(SidebarView)

    const {getAllByRole}= render(createElement(wrappedSidebarView, {number:2, dishes:[dishesConst[0]]}))

    const buttons= getAllByRole("button");
    expect(buttons.length).toEqual(3)  // plus, minus and the x button of the only dish

    buttons[0].click()  // click the - button, this should trigger a custom event
    sidebarCustomEvents["decrease number"]= wrappedSidebarView.customEventPop();

    buttons[1].click()  // click the + button, this should trigger a custom event
    sidebarCustomEvents["increase number"]= wrappedSidebarView.customEventPop();

    expect(sidebarCustomEvents["decrease number"].name).toEqual(sidebarCustomEvents["increase number"].name)
    // trigger more custom events here
    // ...

    sidebarCustomEvents.complete= true;
    return sidebarCustomEvents;
}
```
See the initial implementations in `webCustomEvents.js`, `nativeCustomEvents.js` .  
* the method `sidebar()` could be used in SidebarView test to check that the View fires custom events correctly. It will throw if any expect fails. However, we might decide to simply repeat (parts of) the code in the SidebarView tets rather than calling sidebar(). It may be confusing for the students that their custom event firing is checked in some central place, rather than in the `tw1.4.native.test.js` or `tw1.4.web.test.js`. On the other hand we want to share the code between View and Presenter tests, for reliability and maintainability reasons
* `getCustomEvents("sidebar")` is meant to be used in presenter tests for handling custom events. It will not throw any errors, just return an object like `{complete:false, error:"some error"}`.  Therefore if the presenter test sees `complete:false`, it can skip the test since there are no custom event names ready.

TODO: The parameteres sent to fired custom events should be tested in the View tests. In the example above we can do
```
buttons[2].click()  // click the x button, this should trigger a custom event
sidebarCustomEvents["remove dish"]= wrappedSidebarView.customEventPop();

// the dish removed should be the one we passed to the view via props!
expect(sidebarCustomEvents["remove dish"].params).toEqual([dishesConst[0]])
```
Sometimes students pass custom event parameters when in fact no parameter is needed (e.g. the "add dish" custom event from DetailsView). We can check that `params.length` is zero in that case.


## more technical details about the Vite/Vitest config
### The JSX createElement function
Normally a Vite plugin is used to interpret the JSX for a given framework. That plugin simply creates some Babel configuration to ensure translation from JSX to JS. By default (with no configuration) Babel transforms `<Compo prop1={expr1} p2={e2} />` into `React.createElement(Compo, {prop1:expr1, p2:e2})`

Therefore, before rendering with a certain framework, we simply set `window.React={createElement:someValue}`. Both React and React native use `import {createElement} from "react"`, while Vue uses `import {h} from "vue"`. See how they are set in e.g. [presenterMocks](https://gits-15.sys.kth.se/iprog/iprog-test/blob/main/test/presenterMocks.js)

### Wrapping the JSX createElement for mocking
Expo Image and React Native FlatList do not work in vitest. However, we do not need them to work, we merely want to see that the student uses them correctly, passes the right props, etc.  `vi.mock("react-native", function() {  return { FlatList:vi.fn(), etc:..}})`  does not work well either.

But we can mock FlatList with another technique which we used a lot in the old Mocha (web) tests. We can easily wrap the `createElement` as follows

```
import {createElement} from "react"
window.React={
  createElement:function(compo, props, ...rest){
     // at this point we know what component is being rendered and we can replace it with something else
     return createElement(compo, props, ...rest);
  }
}
```

To replace every `FlatList` with a `Text`: `if(compo==FlatList) return createElement(Text, props, "FlatList replacement")` . The FlatList props will be assigned to the Text so we can retrieve them during testing. See how this is done in [nativeJsxMocks](https://gits-15.sys.kth.se/iprog/iprog-test/blob/main/test/nativeJsxMock.js#L39)

### Web and native environments
There are a few more configurations needed in [vite.config.mjs](https://gits-15.sys.kth.se/iprog/iprog-test/blob/main/vite.config.mjs)
* web rendering needs a DOM environment, like a `window` and `document` objects. We use the package `happy-dom` for that, and it does not disturb React Native rendering
* React Native rendering needs the `vitest-react-native` Vite plugin. Does not interfere with Web rendering

### Aliases
Vite allows us to alias one file name to another. If we alias `a` to `b` any import from `a` will actually load the file `b`. Things are a bit more complex because the import from `a` can be absolute or relative, or the import can be to `a` , `a.js`, `a.ts`  etc. Up to now it seems that all these paths need to be aliased to `b` explicitly.

Aliases made in [aliases.js](https://gits-15.sys.kth.se/iprog/iprog-test/blob/main/test/aliases.js) and meant to be imported in `vite.config.mjs` (in both `iprog-tests` for test testing nad in `tutorial6` for test running)
* teacherFetch does not need to run during testing so it is aliased to an empty file (`test/dummy/teacherFetch.js`). You should never see "DH262 fetch handler installed" on the console during testing
* all `src/views/someView` are aliased to empty files `test/dummy/someView.js`. This is because in presenters we want the import `src/views/someView` to work but we don't need the actual view, since we will mock it anyway
* `src/web-views/someView`  is aliased to the actual file `src/views/someView`. This gives Web View unit tests access to the actual View source code.
* `src/native-views/` is not aliased. It can be accessed when testing the native Views.
* does this aliasing mean that we never could actually test the presenters and views together? At this point we don't do such "integration" tests, but the solution is to mock `src/view/someView` and we make the mock to load `src/web-views/someView` or `src/native-views/someView` as desired. For native we would need a solution regarding flatlist but some easy implementation (e.g. array.map()) can be added
