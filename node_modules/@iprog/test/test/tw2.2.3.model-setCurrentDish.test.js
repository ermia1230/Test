import {describe, it, vi, expect} from "vitest";
import {checkCB} from "./checkCB";
import {getModule} from "./getModule";

vi.mock("vue");
import {reactive, watch} from "vue";
reactive.mockImplementation(function(x){ return {...x};});

vi.mock("mobx");
import {observable, reaction} from "mobx";
observable.mockImplementation(function(x){ return {...x};});

vi.mock("/src/firestoreModel");

import {model} from "/src/DinnerModel"; 

const dishSource= await getModule("/src/dishSource");
vi.mock("/src/dishSource");
import.meta.glob("/src/dishSource.*s");

const {getDishDetails} = dishSource || {};

const resolvePromiseModule= await getModule("/src/resolvePromise");
const {resolvePromise}= resolvePromiseModule||{};

vi.mock("/src/resolvePromise");

import.meta.glob("/src/resolvePromise.*s");


describe.runIf(model.currentDishPromiseState)("TW2.2.3 Promise State in Model with currentDish", function(){
  it("Model defines property currentDishPromiseState initialized to empty object", function() {
      expect(model.currentDishPromiseState).toEqual({});
  });
  
  it.runIf(getDishDetails && resolvePromise)
  ("currentDishEffect sets currentDishPromiseState if currentDishId is truthy", async function tw2_2_3_2() {
      expect(model.currentDishPromiseState).toBeTruthy();    
      const dishId = 601651;
      model.currentDishId= dishId;
      model.currentDishEffect();
      
      expect(getDishDetails).toHaveBeenCalledWith(dishId);
      expect(resolvePromise).toHaveBeenCalledWith(getDishDetails.mock.results[0].value, model.currentDishPromiseState);
  });

  it.runIf(getDishDetails && resolvePromise)
  ("currentDishEffect does not initiate a promise when currentDishId is falsy", async function tw2_2_3_3() {
      model.currentDishId=undefined;
      model.currentDishPromiseState={promise:"dummyPromise", data:"dummyData"};
      
      model.currentDishEffect();

      expect(model.currentDishPromiseState).toBeDefined();
      expect(getDishDetails).not.toHaveBeenCalled();

      if(resolvePromise.mock.calls.length)  // in this case the student may or may not use resolvePromise
          expect(resolvePromise).toHaveBeenCalledWith(expect.toBeFalsy, model.currentDishPromiseState);
      else{
          expect( model.currentDishPromiseState.promise).toBeFalsy();
          expect(model.currentDishPromiseState.data || model.currentDishPromiseState.error).toBeFalsy();
      }
  });
});

// tests below need to re-run when any of the the reactiveModel files changes
import.meta.glob("/src/vueReactiveModel.*s")
import.meta.glob("/src/mobxReactiveModel.*s")

describe.runIf(model.currentDishPromiseState)("TW2.2.3 reactive model setup installs current dish side effect", async function(){
    vi.doMock("/src/DinnerModel");
    const model= (await import("/src/DinnerModel"))?.model;

    it.for([
        {
            module:"/src/vueReactiveModel.js",
            name:"vue",
            sideEffect: watch
        },
        {
            module:"/src/mobxReactiveModel.js",
            name:"mobx",
            sideEffect: reaction
        }
    ])
    ("$name reactive model has a side effect for the current dish",
      async function(rModel, context){
          const ret= await import(rModel.module); // import the module and get its exported object
          
          if(typeof ret?.reactiveModel==="string"){
              console.warn("return an object to enable");
              context.skip();
          }

          expect(rModel.sideEffect).toHaveBeenCalled();

          expect(rModel.sideEffect.mock.calls[0].length).toBe(2);
          const [firstCB, secondCB]= rModel.sideEffect.mock.calls[0];
          
          ret.reactiveModel.currentDishId=15;
          const result1= JSON.stringify(firstCB());
          ret.reactiveModel.currentDishId=16;
          const result2= JSON.stringify(firstCB());
          
          expect(result2).not.toBe(result1);
          
          secondCB(result1);

          expect(model.currentDishEffect).toHaveBeenCalledWith();  // no params needed

          // even when the currentDishId is undefined...
          secondCB([undefined]);

          // the currentDishEffect should be invoked
          expect(model.currentDishEffect.mock.calls.length).toBe(2)
          expect(model.currentDishEffect.mock.calls[1]).toEqual([])
        
          checkCB(firstCB, "current dish side effect first callback");
          checkCB(secondCB, "current dish side effect second callback");
      }); 
});
