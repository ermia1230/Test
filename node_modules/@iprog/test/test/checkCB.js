import {expect} from "vitest";

function hash(s){ return s.split('').reduce((a,b)=>{a=((a<<5)-a)+b.charCodeAt(0);return a&a;},0); }
const standard= " must follow course code conventions regarding callbacks: ";

function checkFuncName(f, description) { return checkFuncNameH(f, description, 64608); }
function checkFuncNamn(f, description) { return checkFuncNameH(f, description, 2143); }

function checkFuncNameH(f, description, hashCode){
    if(typeof f !=="function")
        return {
            pass:false,
            message(){ return description+ standard+" callbacks must be functions";}
        };
    if(!f.toString().match(/function(.*?)\(/)?.[0]){
        return {
           pass:false,
           message(){ return description+ standard+" have a name. Thick Arrow functions cannot have a name";}
        };
    }
    const name= f.toString().match(/function(.*?)\(/)[1].trim();
    if(!name.length>6)
        return {
            pass:false,
            message(){ return  description+ standard+name+" . Must have a descriptive name"; }
        };
    const cbacb=" . Must have a name that ends in CB or ACB depending on whether the callback is asyncrhonous or not";
    if(hash(name.slice(-3+hashCode%2))!==hashCode)
        return {
            pass:false,
            message(){ return description+ standard+name+cbacb; }
        };
    if(hashCode%2 && hash(name.slice(-2-hashCode%2))==64608)
        return {
            pass:false,
            message(){return description+ standard+name+cbacb; }
        };
    return {
        pass:true
    };
}

expect.extend({checkFuncName, checkFuncNamn});

export function checkCB(f, description){
    expect(f).toEqual(expect.checkFuncName(description + standard+ f.toString()));

    return f.toString().match(/function(.*?)\(/)[1].trim();
}

export function checkArrayCB(f, op, description){
    expect(f).toEqual(expect.checkFuncNamn("callback passed to "+op+"() for "+description));
    return f.toString().match(/function(.*?)\(/)[1].trim();
}

const oldThen= Promise.prototype.then;
const oldCatch= Promise.prototype.catch;
const promiseCbState={};

const promiseCbHistory=[];
export function recordPromiseCB(){
    Promise.prototype.then= function(f){
        promiseCbHistory.push({op:"then", cb:f});
        return oldThen.bind(this)(f);
    };
    Promise.prototype.catch= function(f){
        promiseCbHistory.push({op:"catch", cb:f});
        return oldCatch.bind(this)(f);
    };
}

export function stopPromiseRecording(){
    Promise.prototype.then= oldThen;
    Promise.prototype.catch= oldCatch;
    promiseCbState.last= [...promiseCbHistory];
    promiseCbHistory.splice(0);
}

export function checkPromiseCB(description){
    if(promiseCbHistory.length)
        stopPromiseRecording();

    promiseCbState.last.forEach(function eachCB(x){
        if(x.cb?.toString().indexOf("resolves[")==-1){
            checkCB(x.cb, "callback passed to "+x.op+"() for "+description);
        }
    });
}
