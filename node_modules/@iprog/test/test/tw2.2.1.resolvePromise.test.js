import { describe, it, expect } from "vitest";

import {getModule} from "./getModule";

// re-run these tests if resolvePromise.js changes, getModule does not do that
import.meta.glob("/src/resolvePromise.*s")

const {resolvePromise} =await getModule("/src/resolvePromise");

function sleep(ms) {
    return new Promise(function(resolve){ setTimeout(resolve, ms);});
}
describe.runIf(resolvePromise)("TW2.2.1 resolvePromise", function tw2_2_1() {
    it("resolvePromise sets data after the promise resolves", async function tw2_2_1_1() {
	const promiseState = {};
	
	resolvePromise(
	    sleep(10).then(function successACB(){return 42; }),
	    promiseState,
	);
	
	expect(promiseState.promise).toBeTruthy();
	expect(promiseState.data).toBeNull();
	expect(promiseState.error).toBeNull();

	await sleep(15);

	expect(promiseState.promise).toBeTruthy();
	expect(promiseState.data).toBe(42);
	expect(promiseState.error).toBeNull();
    }, 20000);
    
    it("resolvePromise sets error after the promise rejects", async function tw2_2_1_2() {
	const promiseState = {};
	
	resolvePromise(
	    sleep(10).then(function errorACB() {
		throw 42;
	    }),
	    promiseState,
	);

	expect(promiseState.promise).toBeTruthy();
	expect(promiseState.data).toBeNull();
	expect(promiseState.error).toBeNull();

	await sleep(15);
	
	expect(promiseState.promise).toBeTruthy();
	expect(promiseState.error).toBe(42);
	expect(promiseState.data).toBeNull();
    }, 20000);

    it("resolvePromise checks for falsy promise", async function tw2_2_1_3() {
	const promiseState = {promise:"dummy promise", data:"dummy data", error:"dummy error"};
	expect(function(){  resolvePromise(null, promiseState);}).not.toThrow();

	// promise, data and error set to falsy by a resolve promise with falsy promise
	expect(promiseState.promise || promiseState.data || promiseState.error).toBeFalsy();
	
	const promiseState1 = {promise:"dummy promise", data:"dummy data", error:"dummy error"};
	expect(function(){ resolvePromise(undefined, promiseState1);}).not.toThrow();
	expect(promiseState1.promise || promiseState1.data || promiseState1.error).toBeFalsy();
    });

    it("resolvePromise check for race condition", async function tw2_2_1_4() {
	const promiseState = {};
	
	const slowPromise = sleep(100).then(function resolveToStringACB(){ return"result after 100ms";});

	const quickPromise= sleep(2).then(function  resolveToStringACB(){ return"result after 2ms";});

	// resolvePromise on first promise
	resolvePromise(slowPromise, promiseState);
	// wait a bit
	await sleep(3);
	// resolvePromise on second promise, it will resolve ~95ms before the first!
	resolvePromise(quickPromise, promiseState);

	// wait for both promises to resolve
	await Promise.all([slowPromise, quickPromise]);

	// the promiseState contains the latest promise
	expect(promiseState.promise).toBe(quickPromise);
	// ...and its result
	expect(promiseState.data).toBe("result after 2ms");
	// that is, the result of the first promise is ignored, even if it's "the latest" to come
    }, 20000);
});

